/**
 * @react-router/dev v7.9.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// internal.ts
var internal_exports = {};
__export(internal_exports, {
  __INTERNAL_DO_NOT_USE_OR_YOU_WILL_GET_A_STRONGLY_WORDED_LETTER__: () => __INTERNAL_DO_NOT_USE_OR_YOU_WILL_GET_A_STRONGLY_WORDED_LETTER__
});
module.exports = __toCommonJS(internal_exports);

// vite/rsc/plugin.ts
var import_es_module_lexer2 = require("es-module-lexer");
var Path5 = __toESM(require("pathe"));
var babel = __toESM(require("@babel/core"));
var import_picocolors4 = __toESM(require("picocolors"));

// vite/virtual-module.ts
function create(name) {
  let id = `virtual:react-router/${name}`;
  return {
    id,
    resolvedId: `\0${id}`,
    url: `/@id/__x00__${id}`
  };
}

// typegen/index.ts
var import_promises = __toESM(require("fs/promises"));
var Path4 = __toESM(require("pathe"));
var import_picocolors2 = require("picocolors");

// config/config.ts
var import_node_fs = __toESM(require("fs"));
var import_node_child_process = require("child_process");
var import_package_json = __toESM(require("@npmcli/package-json"));

// vite/vite.ts
var import_pathe2 = __toESM(require("pathe"));

// invariant.ts
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    console.error(
      "The following error is a bug in React Router; please open an issue! https://github.com/remix-run/react-router/issues/new/choose"
    );
    throw new Error(message);
  }
}

// config/is-react-router-repo.ts
var import_pathe = __toESM(require("pathe"));
function isReactRouterRepo() {
  let serverRuntimePath = import_pathe.default.dirname(
    require.resolve("@react-router/node/package.json")
  );
  let serverRuntimeParentDir = import_pathe.default.basename(
    import_pathe.default.resolve(serverRuntimePath, "..")
  );
  return serverRuntimeParentDir === "packages";
}

// vite/vite.ts
var vite;
var viteImportSpecifier = isReactRouterRepo() ? (
  // Support testing against different versions of Vite by ensuring that Vite
  // is resolved from the current working directory when running within this
  // repo. If we don't do this, Vite will always be imported relative to this
  // file, which means that it will always resolve to Vite 6.
  `file:///${import_pathe2.default.normalize(
    require.resolve("vite/package.json", { paths: [process.cwd()] })
  ).replace("package.json", "dist/node/index.js")}`
) : "vite";
async function preloadVite() {
  vite = await import(viteImportSpecifier);
}
function getVite() {
  invariant(vite, "getVite() called before preloadVite()");
  return vite;
}

// vite/ssr-externals.ts
var ssrExternals = isReactRouterRepo() ? [
  // This is only needed within this repo because these packages
  // are linked to a directory outside of node_modules so Vite
  // treats them as internal code by default.
  "react-router",
  "react-router-dom",
  "@react-router/architect",
  "@react-router/cloudflare",
  "@react-router/dev",
  "@react-router/express",
  "@react-router/node",
  "@react-router/serve"
] : void 0;

// vite/vite-node.ts
async function createContext({
  root,
  mode,
  customLogger
}) {
  await preloadVite();
  const vite2 = getVite();
  const [{ ViteNodeServer }, { ViteNodeRunner }, { installSourcemapsSupport }] = await Promise.all([
    import("vite-node/server"),
    import("vite-node/client"),
    import("vite-node/source-map")
  ]);
  const devServer = await vite2.createServer({
    root,
    mode,
    customLogger,
    server: {
      preTransformRequests: false,
      hmr: false,
      watch: null
    },
    ssr: {
      external: ssrExternals
    },
    optimizeDeps: {
      noDiscovery: true
    },
    css: {
      // This empty PostCSS config object prevents the PostCSS config file from
      // being loaded. We don't need it in a React Router config context, and
      // there's also an issue in Vite 5 when using a .ts PostCSS config file in
      // an ESM project: https://github.com/vitejs/vite/issues/15869. Consumers
      // can work around this in their own Vite config file, but they can't
      // configure this internal usage of vite-node.
      postcss: {}
    },
    configFile: false,
    envFile: false,
    plugins: []
  });
  await devServer.pluginContainer.buildStart({});
  const server = new ViteNodeServer(devServer);
  installSourcemapsSupport({
    getSourceMap: (source) => server.getSourceMap(source)
  });
  const runner = new ViteNodeRunner({
    root: devServer.config.root,
    base: devServer.config.base,
    fetchModule(id) {
      return server.fetchModule(id);
    },
    resolveId(id, importer) {
      return server.resolveId(id, importer);
    }
  });
  return { devServer, server, runner };
}

// config/config.ts
var import_pathe3 = __toESM(require("pathe"));
var import_chokidar = __toESM(require("chokidar"));
var import_picocolors = __toESM(require("picocolors"));
var import_pick2 = __toESM(require("lodash/pick"));
var import_omit = __toESM(require("lodash/omit"));
var import_cloneDeep = __toESM(require("lodash/cloneDeep"));
var import_isEqual = __toESM(require("lodash/isEqual"));

// config/routes.ts
var Path = __toESM(require("pathe"));
var v = __toESM(require("valibot"));
var import_pick = __toESM(require("lodash/pick"));
function setAppDirectory(directory) {
  globalThis.__reactRouterAppDirectory = directory;
}
var routeConfigEntrySchema = v.pipe(
  v.custom((value) => {
    return !(typeof value === "object" && value !== null && "then" in value && "catch" in value);
  }, "Invalid type: Expected object but received a promise. Did you forget to await?"),
  v.object({
    id: v.optional(
      v.pipe(
        v.string(),
        v.notValue("root", "A route cannot use the reserved id 'root'.")
      )
    ),
    path: v.optional(v.string()),
    index: v.optional(v.boolean()),
    caseSensitive: v.optional(v.boolean()),
    file: v.string(),
    children: v.optional(v.array(v.lazy(() => routeConfigEntrySchema)))
  })
);
var resolvedRouteConfigSchema = v.array(routeConfigEntrySchema);
function validateRouteConfig({
  routeConfigFile,
  routeConfig
}) {
  if (!routeConfig) {
    return {
      valid: false,
      message: `Route config must be the default export in "${routeConfigFile}".`
    };
  }
  if (!Array.isArray(routeConfig)) {
    return {
      valid: false,
      message: `Route config in "${routeConfigFile}" must be an array.`
    };
  }
  let { issues } = v.safeParse(resolvedRouteConfigSchema, routeConfig);
  if (issues?.length) {
    let { root, nested } = v.flatten(issues);
    return {
      valid: false,
      message: [
        `Route config in "${routeConfigFile}" is invalid.`,
        root ? `${root}` : [],
        nested ? Object.entries(nested).map(
          ([path6, message]) => `Path: routes.${path6}
${message}`
        ) : []
      ].flat().join("\n\n")
    };
  }
  return {
    valid: true,
    routeConfig
  };
}
function configRoutesToRouteManifest(appDirectory, routes) {
  let routeManifest = {};
  function walk(route, parentId) {
    let id = route.id || createRouteId(route.file);
    let manifestItem = {
      id,
      parentId,
      file: Path.isAbsolute(route.file) ? Path.relative(appDirectory, route.file) : route.file,
      path: route.path,
      index: route.index,
      caseSensitive: route.caseSensitive
    };
    if (routeManifest.hasOwnProperty(id)) {
      throw new Error(
        `Unable to define routes with duplicate route id: "${id}"`
      );
    }
    routeManifest[id] = manifestItem;
    if (route.children) {
      for (let child of route.children) {
        walk(child, id);
      }
    }
  }
  for (let route of routes) {
    walk(route);
  }
  return routeManifest;
}
function createRouteId(file) {
  return Path.normalize(stripFileExtension(file));
}
function stripFileExtension(file) {
  return file.replace(/\.[a-z0-9]+$/i, "");
}

// config/config.ts
var excludedConfigPresetKeys = ["presets"];
var mergeReactRouterConfig = (...configs) => {
  let reducer = (configA, configB) => {
    let mergeRequired = (key) => configA[key] !== void 0 && configB[key] !== void 0;
    return {
      ...configA,
      ...configB,
      ...mergeRequired("buildEnd") ? {
        buildEnd: async (...args) => {
          await Promise.all([
            configA.buildEnd?.(...args),
            configB.buildEnd?.(...args)
          ]);
        }
      } : {},
      ...mergeRequired("future") ? {
        future: {
          ...configA.future,
          ...configB.future
        }
      } : {},
      ...mergeRequired("presets") ? {
        presets: [...configA.presets ?? [], ...configB.presets ?? []]
      } : {}
    };
  };
  return configs.reduce(reducer, {});
};
var deepFreeze = (o) => {
  Object.freeze(o);
  let oIsFunction = typeof o === "function";
  let hasOwnProp = Object.prototype.hasOwnProperty;
  Object.getOwnPropertyNames(o).forEach(function(prop) {
    if (hasOwnProp.call(o, prop) && (oIsFunction ? prop !== "caller" && prop !== "callee" && prop !== "arguments" : true) && o[prop] !== null && (typeof o[prop] === "object" || typeof o[prop] === "function") && !Object.isFrozen(o[prop])) {
      deepFreeze(o[prop]);
    }
  });
  return o;
};
function ok(value) {
  return { ok: true, value };
}
function err(error) {
  return { ok: false, error };
}
async function resolveConfig({
  root,
  viteNodeContext,
  reactRouterConfigFile,
  skipRoutes,
  validateConfig
}) {
  let reactRouterUserConfig = {};
  if (reactRouterConfigFile) {
    try {
      if (!import_node_fs.default.existsSync(reactRouterConfigFile)) {
        return err(`${reactRouterConfigFile} no longer exists`);
      }
      let configModule = await viteNodeContext.runner.executeFile(
        reactRouterConfigFile
      );
      if (configModule.default === void 0) {
        return err(`${reactRouterConfigFile} must provide a default export`);
      }
      if (typeof configModule.default !== "object") {
        return err(`${reactRouterConfigFile} must export a config`);
      }
      reactRouterUserConfig = configModule.default;
      if (validateConfig) {
        const error = validateConfig(reactRouterUserConfig);
        if (error) {
          return err(error);
        }
      }
    } catch (error) {
      return err(`Error loading ${reactRouterConfigFile}: ${error}`);
    }
  }
  reactRouterUserConfig = deepFreeze((0, import_cloneDeep.default)(reactRouterUserConfig));
  let presets = (await Promise.all(
    (reactRouterUserConfig.presets ?? []).map(async (preset) => {
      if (!preset.name) {
        throw new Error(
          "React Router presets must have a `name` property defined."
        );
      }
      if (!preset.reactRouterConfig) {
        return null;
      }
      let configPreset = (0, import_omit.default)(
        await preset.reactRouterConfig({ reactRouterUserConfig }),
        excludedConfigPresetKeys
      );
      return configPreset;
    })
  )).filter(function isNotNull(value) {
    return value !== null;
  });
  let defaults = {
    basename: "/",
    buildDirectory: "build",
    serverBuildFile: "index.js",
    serverModuleFormat: "esm",
    ssr: true
  };
  let userAndPresetConfigs = mergeReactRouterConfig(
    ...presets,
    reactRouterUserConfig
  );
  let {
    appDirectory: userAppDirectory,
    basename: basename2,
    buildDirectory: userBuildDirectory,
    buildEnd,
    prerender,
    routeDiscovery: userRouteDiscovery,
    serverBuildFile,
    serverBundles,
    serverModuleFormat,
    ssr
  } = {
    ...defaults,
    // Default values should be completely overridden by user/preset config, not merged
    ...userAndPresetConfigs
  };
  if (!ssr && serverBundles) {
    serverBundles = void 0;
  }
  let isValidPrerenderConfig = prerender == null || typeof prerender === "boolean" || Array.isArray(prerender) || typeof prerender === "function";
  if (!isValidPrerenderConfig) {
    return err(
      "The `prerender` config must be a boolean, an array of string paths, or a function returning a boolean or array of string paths"
    );
  }
  let routeDiscovery;
  if (userRouteDiscovery == null) {
    if (ssr) {
      routeDiscovery = {
        mode: "lazy",
        manifestPath: "/__manifest"
      };
    } else {
      routeDiscovery = { mode: "initial" };
    }
  } else if (userRouteDiscovery.mode === "initial") {
    routeDiscovery = userRouteDiscovery;
  } else if (userRouteDiscovery.mode === "lazy") {
    if (!ssr) {
      return err(
        'The `routeDiscovery.mode` config cannot be set to "lazy" when setting `ssr:false`'
      );
    }
    let { manifestPath } = userRouteDiscovery;
    if (manifestPath != null && !manifestPath.startsWith("/")) {
      return err(
        'The `routeDiscovery.manifestPath` config must be a root-relative pathname beginning with a slash (i.e., "/__manifest")'
      );
    }
    routeDiscovery = userRouteDiscovery;
  }
  let appDirectory = import_pathe3.default.resolve(root, userAppDirectory || "app");
  let buildDirectory = import_pathe3.default.resolve(root, userBuildDirectory);
  let rootRouteFile = findEntry(appDirectory, "root", { absolute: true });
  if (!rootRouteFile) {
    let rootRouteDisplayPath = import_pathe3.default.relative(
      root,
      import_pathe3.default.join(appDirectory, "root.tsx")
    );
    return err(
      `Could not find a root route module in the app directory as "${rootRouteDisplayPath}"`
    );
  }
  let routes;
  let routeConfig = [];
  if (skipRoutes) {
    routes = {};
  } else {
    let routeConfigFile = findEntry(appDirectory, "routes");
    try {
      if (!routeConfigFile) {
        let routeConfigDisplayPath = import_pathe3.default.relative(
          root,
          import_pathe3.default.join(appDirectory, "routes.ts")
        );
        return err(
          `Route config file not found at "${routeConfigDisplayPath}".`
        );
      }
      setAppDirectory(appDirectory);
      let routeConfigExport = (await viteNodeContext.runner.executeFile(
        import_pathe3.default.join(appDirectory, routeConfigFile)
      )).default;
      let result = validateRouteConfig({
        routeConfigFile,
        routeConfig: await routeConfigExport
      });
      if (!result.valid) {
        return err(result.message);
      }
      routeConfig = [
        {
          id: "root",
          path: "",
          file: import_pathe3.default.relative(appDirectory, rootRouteFile),
          children: result.routeConfig
        }
      ];
      routes = configRoutesToRouteManifest(appDirectory, routeConfig);
    } catch (error) {
      return err(
        [
          import_picocolors.default.red(`Route config in "${routeConfigFile}" is invalid.`),
          "",
          error.loc?.file && error.loc?.column && error.frame ? [
            import_pathe3.default.relative(appDirectory, error.loc.file) + ":" + error.loc.line + ":" + error.loc.column,
            error.frame.trim?.()
          ] : error.stack
        ].flat().join("\n")
      );
    }
  }
  let future = {
    v8_middleware: reactRouterUserConfig.future?.v8_middleware ?? false,
    unstable_optimizeDeps: reactRouterUserConfig.future?.unstable_optimizeDeps ?? false,
    unstable_splitRouteModules: reactRouterUserConfig.future?.unstable_splitRouteModules ?? false,
    unstable_subResourceIntegrity: reactRouterUserConfig.future?.unstable_subResourceIntegrity ?? false,
    unstable_viteEnvironmentApi: reactRouterUserConfig.future?.unstable_viteEnvironmentApi ?? false
  };
  let reactRouterConfig = deepFreeze({
    appDirectory,
    basename: basename2,
    buildDirectory,
    buildEnd,
    future,
    prerender,
    routes,
    routeDiscovery,
    serverBuildFile,
    serverBundles,
    serverModuleFormat,
    ssr,
    unstable_routeConfig: routeConfig
  });
  for (let preset of reactRouterUserConfig.presets ?? []) {
    await preset.reactRouterConfigResolved?.({ reactRouterConfig });
  }
  return ok(reactRouterConfig);
}
async function createConfigLoader({
  rootDirectory: root,
  watch: watch2,
  mode,
  skipRoutes,
  validateConfig
}) {
  root = import_pathe3.default.normalize(root ?? process.env.REACT_ROUTER_ROOT ?? process.cwd());
  let vite2 = await import("vite");
  let viteNodeContext = await createContext({
    root,
    mode,
    // Filter out any info level logs from vite-node
    customLogger: vite2.createLogger("warn", {
      prefix: "[react-router]"
    })
  });
  let reactRouterConfigFile;
  let updateReactRouterConfigFile = () => {
    reactRouterConfigFile = findEntry(root, "react-router.config", {
      absolute: true
    });
  };
  updateReactRouterConfigFile();
  let getConfig = () => resolveConfig({
    root,
    viteNodeContext,
    reactRouterConfigFile,
    skipRoutes,
    validateConfig
  });
  let appDirectory;
  let initialConfigResult = await getConfig();
  if (!initialConfigResult.ok) {
    throw new Error(initialConfigResult.error);
  }
  appDirectory = import_pathe3.default.normalize(initialConfigResult.value.appDirectory);
  let currentConfig = initialConfigResult.value;
  let fsWatcher;
  let changeHandlers = [];
  return {
    getConfig,
    onChange: (handler) => {
      if (!watch2) {
        throw new Error(
          "onChange is not supported when watch mode is disabled"
        );
      }
      changeHandlers.push(handler);
      if (!fsWatcher) {
        fsWatcher = import_chokidar.default.watch([root, appDirectory], {
          ignoreInitial: true,
          ignored: (path6) => {
            let dirname4 = import_pathe3.default.dirname(path6);
            return !dirname4.startsWith(appDirectory) && // Ensure we're only watching files outside of the app directory
            // that are at the root level, not nested in subdirectories
            path6 !== root && // Watch the root directory itself
            dirname4 !== root;
          }
        });
        fsWatcher.on("all", async (...args) => {
          let [event, rawFilepath] = args;
          let filepath = import_pathe3.default.normalize(rawFilepath);
          let fileAddedOrRemoved = event === "add" || event === "unlink";
          let appFileAddedOrRemoved = fileAddedOrRemoved && filepath.startsWith(import_pathe3.default.normalize(appDirectory));
          let rootRelativeFilepath = import_pathe3.default.relative(root, filepath);
          let configFileAddedOrRemoved = fileAddedOrRemoved && isEntryFile("react-router.config", rootRelativeFilepath);
          if (configFileAddedOrRemoved) {
            updateReactRouterConfigFile();
          }
          let moduleGraphChanged = configFileAddedOrRemoved || Boolean(
            viteNodeContext.devServer?.moduleGraph.getModuleById(filepath)
          );
          if (!moduleGraphChanged && !appFileAddedOrRemoved) {
            return;
          }
          viteNodeContext.devServer?.moduleGraph.invalidateAll();
          viteNodeContext.runner?.moduleCache.clear();
          let result = await getConfig();
          let prevAppDirectory = appDirectory;
          appDirectory = import_pathe3.default.normalize(
            (result.value ?? currentConfig).appDirectory
          );
          if (appDirectory !== prevAppDirectory) {
            fsWatcher.unwatch(prevAppDirectory);
            fsWatcher.add(appDirectory);
          }
          let configCodeChanged = configFileAddedOrRemoved || reactRouterConfigFile !== void 0 && isEntryFileDependency(
            viteNodeContext.devServer.moduleGraph,
            reactRouterConfigFile,
            filepath
          );
          let routeConfigFile = !skipRoutes ? findEntry(appDirectory, "routes", {
            absolute: true
          }) : void 0;
          let routeConfigCodeChanged = routeConfigFile !== void 0 && isEntryFileDependency(
            viteNodeContext.devServer.moduleGraph,
            routeConfigFile,
            filepath
          );
          let configChanged = result.ok && !(0, import_isEqual.default)(omitRoutes(currentConfig), omitRoutes(result.value));
          let routeConfigChanged = result.ok && !(0, import_isEqual.default)(currentConfig?.routes, result.value.routes);
          for (let handler2 of changeHandlers) {
            handler2({
              result,
              configCodeChanged,
              routeConfigCodeChanged,
              configChanged,
              routeConfigChanged,
              path: filepath,
              event
            });
          }
          if (result.ok) {
            currentConfig = result.value;
          }
        });
      }
      return () => {
        changeHandlers = changeHandlers.filter(
          (changeHandler) => changeHandler !== handler
        );
      };
    },
    close: async () => {
      changeHandlers = [];
      await viteNodeContext.devServer.close();
      await fsWatcher?.close();
    }
  };
}
function omitRoutes(config) {
  return {
    ...config,
    routes: {}
  };
}
var entryExts = [".js", ".jsx", ".ts", ".tsx", ".mjs", ".mts"];
function isEntryFile(entryBasename, filename2) {
  return entryExts.some((ext) => filename2 === `${entryBasename}${ext}`);
}
function findEntry(dir, basename2, options) {
  let currentDir = import_pathe3.default.resolve(dir);
  let { root } = import_pathe3.default.parse(currentDir);
  while (true) {
    for (let ext of options?.extensions ?? entryExts) {
      let file = import_pathe3.default.resolve(currentDir, basename2 + ext);
      if (import_node_fs.default.existsSync(file)) {
        return options?.absolute ?? false ? file : import_pathe3.default.relative(dir, file);
      }
    }
    if (!options?.walkParents) {
      return void 0;
    }
    let parentDir = import_pathe3.default.dirname(currentDir);
    if (currentDir === root || parentDir === currentDir) {
      return void 0;
    }
    currentDir = parentDir;
  }
}
function isEntryFileDependency(moduleGraph, entryFilepath, filepath, visited = /* @__PURE__ */ new Set()) {
  entryFilepath = import_pathe3.default.normalize(entryFilepath);
  filepath = import_pathe3.default.normalize(filepath);
  if (visited.has(filepath)) {
    return false;
  }
  visited.add(filepath);
  if (filepath === entryFilepath) {
    return true;
  }
  let mod = moduleGraph.getModuleById(filepath);
  if (!mod) {
    return false;
  }
  for (let importer of mod.importers) {
    if (!importer.id) {
      continue;
    }
    if (importer.id === entryFilepath || isEntryFileDependency(moduleGraph, entryFilepath, importer.id, visited)) {
      return true;
    }
  }
  return false;
}

// typegen/context.ts
async function createContext2({
  rootDirectory,
  watch: watch2,
  mode,
  rsc
}) {
  const configLoader = await createConfigLoader({ rootDirectory, mode, watch: watch2 });
  const configResult = await configLoader.getConfig();
  if (!configResult.ok) {
    throw new Error(configResult.error);
  }
  const config = configResult.value;
  return {
    configLoader,
    rootDirectory,
    config,
    rsc
  };
}

// typegen/generate.ts
var import_dedent = __toESM(require("dedent"));
var Path3 = __toESM(require("pathe"));
var Pathe = __toESM(require("pathe/utils"));

// vite/babel.ts
var babel_exports = {};
__export(babel_exports, {
  generate: () => generate,
  parse: () => import_parser.parse,
  t: () => t,
  traverse: () => traverse
});
var import_parser = require("@babel/parser");
var t = __toESM(require("@babel/types"));
var traverse = require("@babel/traverse").default;
var generate = require("@babel/generator").default;

// typegen/params.ts
function parse2(fullpath2) {
  const result = {};
  let segments = fullpath2.split("/");
  segments.forEach((segment) => {
    const match = segment.match(/^:([\w-]+)(\?)?/);
    if (!match) return;
    const param = match[1];
    const isRequired = match[2] === void 0;
    result[param] ||= isRequired;
    return;
  });
  const hasSplat = segments.at(-1) === "*";
  if (hasSplat) result["*"] = true;
  return result;
}

// typegen/route.ts
function lineage(routes, route) {
  const result = [];
  while (route) {
    result.push(route);
    if (!route.parentId) break;
    route = routes[route.parentId];
  }
  result.reverse();
  return result;
}
function fullpath(lineage2) {
  const route = lineage2.at(-1);
  if (lineage2.length === 1 && route?.id === "root") return "/";
  const isLayout = route && route.index !== true && route.path === void 0;
  if (isLayout) return void 0;
  return "/" + lineage2.map((route2) => route2.path?.replace(/^\//, "")?.replace(/\/$/, "")).filter((path6) => path6 !== void 0 && path6 !== "").join("/");
}

// typegen/generate.ts
function typesDirectory(ctx) {
  return Path3.join(ctx.rootDirectory, ".react-router/types");
}
function generateFuture(ctx) {
  const filename2 = Path3.join(typesDirectory(ctx), "+future.ts");
  const content = import_dedent.default`
    // Generated by React Router

    import "react-router";

    declare module "react-router" {
      interface Future {
        v8_middleware: ${ctx.config.future.v8_middleware}
      }
    }
  `;
  return { filename: filename2, content };
}
function generateServerBuild(ctx) {
  const filename2 = Path3.join(typesDirectory(ctx), "+server-build.d.ts");
  const content = import_dedent.default`
    // Generated by React Router

    declare module "virtual:react-router/server-build" {
      import { ServerBuild } from "react-router";
      export const assets: ServerBuild["assets"];
      export const assetsBuildDirectory: ServerBuild["assetsBuildDirectory"];
      export const basename: ServerBuild["basename"];
      export const entry: ServerBuild["entry"];
      export const future: ServerBuild["future"];
      export const isSpaMode: ServerBuild["isSpaMode"];
      export const prerender: ServerBuild["prerender"];
      export const publicPath: ServerBuild["publicPath"];
      export const routeDiscovery: ServerBuild["routeDiscovery"];
      export const routes: ServerBuild["routes"];
      export const ssr: ServerBuild["ssr"];
      export const unstable_getCriticalCss: ServerBuild["unstable_getCriticalCss"];
    }
  `;
  return { filename: filename2, content };
}
var { t: t2 } = babel_exports;
function generateRoutes(ctx) {
  const fileToRoutes = /* @__PURE__ */ new Map();
  const lineages = /* @__PURE__ */ new Map();
  const allPages = /* @__PURE__ */ new Set();
  const routeToPages = /* @__PURE__ */ new Map();
  for (const route of Object.values(ctx.config.routes)) {
    let routeIds = fileToRoutes.get(route.file);
    if (!routeIds) {
      routeIds = /* @__PURE__ */ new Set();
      fileToRoutes.set(route.file, routeIds);
    }
    routeIds.add(route.id);
    const lineage2 = lineage(ctx.config.routes, route);
    lineages.set(route.id, lineage2);
    const fullpath2 = fullpath(lineage2);
    if (!fullpath2) continue;
    const pages = expand(fullpath2);
    pages.forEach((page) => allPages.add(page));
    lineage2.forEach(({ id }) => {
      let routePages = routeToPages.get(id);
      if (!routePages) {
        routePages = /* @__PURE__ */ new Set();
        routeToPages.set(id, routePages);
      }
      pages.forEach((page) => routePages.add(page));
    });
  }
  const routesTs = {
    filename: Path3.join(typesDirectory(ctx), "+routes.ts"),
    content: import_dedent.default`
        // Generated by React Router

        import "react-router"

        declare module "react-router" {
          interface Register {
            pages: Pages
            routeFiles: RouteFiles
          }
        }
      ` + "\n\n" + generate(pagesType(allPages)).code + "\n\n" + generate(routeFilesType({ fileToRoutes, routeToPages })).code
  };
  const allAnnotations = Array.from(fileToRoutes.entries()).filter(([file]) => isInAppDirectory(ctx, file)).map(
    ([file, routeIds]) => getRouteAnnotations({ ctx, file, routeIds, lineages })
  );
  return [routesTs, ...allAnnotations];
}
function pagesType(pages) {
  return t2.tsTypeAliasDeclaration(
    t2.identifier("Pages"),
    null,
    t2.tsTypeLiteral(
      Array.from(pages).map((page) => {
        return t2.tsPropertySignature(
          t2.stringLiteral(page),
          t2.tsTypeAnnotation(
            t2.tsTypeLiteral([
              t2.tsPropertySignature(
                t2.identifier("params"),
                t2.tsTypeAnnotation(paramsType(page))
              )
            ])
          )
        );
      })
    )
  );
}
function routeFilesType({
  fileToRoutes,
  routeToPages
}) {
  return t2.tsTypeAliasDeclaration(
    t2.identifier("RouteFiles"),
    null,
    t2.tsTypeLiteral(
      Array.from(fileToRoutes).map(
        ([file, routeIds]) => t2.tsPropertySignature(
          t2.stringLiteral(file),
          t2.tsTypeAnnotation(
            t2.tsUnionType(
              Array.from(routeIds).map((routeId) => {
                const pages = routeToPages.get(routeId) ?? /* @__PURE__ */ new Set();
                return t2.tsTypeLiteral([
                  t2.tsPropertySignature(
                    t2.identifier("id"),
                    t2.tsTypeAnnotation(
                      t2.tsLiteralType(t2.stringLiteral(routeId))
                    )
                  ),
                  t2.tsPropertySignature(
                    t2.identifier("page"),
                    t2.tsTypeAnnotation(
                      pages ? t2.tsUnionType(
                        Array.from(pages).map(
                          (page) => t2.tsLiteralType(t2.stringLiteral(page))
                        )
                      ) : t2.tsNeverKeyword()
                    )
                  )
                ]);
              })
            )
          )
        )
      )
    )
  );
}
function isInAppDirectory(ctx, routeFile) {
  const path6 = Path3.resolve(ctx.config.appDirectory, routeFile);
  return path6.startsWith(ctx.config.appDirectory);
}
function getRouteAnnotations({
  ctx,
  file,
  routeIds,
  lineages
}) {
  const filename2 = Path3.join(
    typesDirectory(ctx),
    Path3.relative(ctx.rootDirectory, ctx.config.appDirectory),
    Path3.dirname(file),
    "+types",
    Pathe.filename(file) + ".ts"
  );
  const matchesType = t2.tsTypeAliasDeclaration(
    t2.identifier("Matches"),
    null,
    t2.tsUnionType(
      Array.from(routeIds).map((routeId) => {
        const lineage2 = lineages.get(routeId);
        return t2.tsTupleType(
          lineage2.map(
            (route) => t2.tsTypeLiteral([
              t2.tsPropertySignature(
                t2.identifier("id"),
                t2.tsTypeAnnotation(t2.tsLiteralType(t2.stringLiteral(route.id)))
              ),
              t2.tsPropertySignature(
                t2.identifier("module"),
                t2.tsTypeAnnotation(
                  t2.tsTypeQuery(
                    t2.tsImportType(
                      t2.stringLiteral(
                        relativeImportSource(
                          rootDirsPath(ctx, filename2),
                          Path3.resolve(ctx.config.appDirectory, route.file)
                        )
                      )
                    )
                  )
                )
              )
            ])
          )
        );
      })
    )
  );
  const routeImportSource = relativeImportSource(
    rootDirsPath(ctx, filename2),
    Path3.resolve(ctx.config.appDirectory, file)
  );
  const content = import_dedent.default`
      // Generated by React Router

      import type { GetInfo, GetAnnotations } from "react-router/internal";

      type Module = typeof import("${routeImportSource}")

      type Info = GetInfo<{
        file: "${file}",
        module: Module
      }>
    ` + "\n\n" + generate(matchesType).code + "\n\n" + import_dedent.default`
      type Annotations = GetAnnotations<Info & { module: Module, matches: Matches }, ${ctx.rsc}>;

      export namespace Route {
        // links
        export type LinkDescriptors = Annotations["LinkDescriptors"];
        export type LinksFunction = Annotations["LinksFunction"];

        // meta
        export type MetaArgs = Annotations["MetaArgs"];
        export type MetaDescriptors = Annotations["MetaDescriptors"];
        export type MetaFunction = Annotations["MetaFunction"];

        // headers
        export type HeadersArgs = Annotations["HeadersArgs"];
        export type HeadersFunction = Annotations["HeadersFunction"];

        // middleware
        export type MiddlewareFunction = Annotations["MiddlewareFunction"];

        // clientMiddleware
        export type ClientMiddlewareFunction = Annotations["ClientMiddlewareFunction"];

        // loader
        export type LoaderArgs = Annotations["LoaderArgs"];

        // clientLoader
        export type ClientLoaderArgs = Annotations["ClientLoaderArgs"];

        // action
        export type ActionArgs = Annotations["ActionArgs"];

        // clientAction
        export type ClientActionArgs = Annotations["ClientActionArgs"];

        // HydrateFallback
        export type HydrateFallbackProps = Annotations["HydrateFallbackProps"];

        // Component
        export type ComponentProps = Annotations["ComponentProps"];

        // ErrorBoundary
        export type ErrorBoundaryProps = Annotations["ErrorBoundaryProps"];
      }
    `;
  return { filename: filename2, content };
}
function relativeImportSource(from, to) {
  let path6 = Path3.relative(Path3.dirname(from), to);
  let extension = Path3.extname(path6);
  path6 = Path3.join(Path3.dirname(path6), Pathe.filename(path6));
  if (!path6.startsWith("../")) path6 = "./" + path6;
  if (!extension || /\.(js|ts)x?$/.test(extension)) {
    extension = ".js";
  }
  return path6 + extension;
}
function rootDirsPath(ctx, typesPath) {
  const rel = Path3.relative(typesDirectory(ctx), typesPath);
  return Path3.join(ctx.rootDirectory, rel);
}
function paramsType(path6) {
  const params = parse2(path6);
  return t2.tsTypeLiteral(
    Object.entries(params).map(([param, isRequired]) => {
      const property = t2.tsPropertySignature(
        t2.stringLiteral(param),
        t2.tsTypeAnnotation(t2.tsStringKeyword())
      );
      property.optional = !isRequired;
      return property;
    })
  );
}
function expand(fullpath2) {
  function recurse(segments2, index) {
    if (index === segments2.length) return [""];
    const segment = segments2[index];
    const isOptional = segment.endsWith("?");
    const isDynamic = segment.startsWith(":");
    const required = segment.replace(/\?$/, "");
    const keep = !isOptional || isDynamic;
    const kept = isDynamic ? segment : required;
    const withoutSegment = recurse(segments2, index + 1);
    const withSegment = withoutSegment.map((rest) => [kept, rest].join("/"));
    if (keep) return withSegment;
    return [...withoutSegment, ...withSegment];
  }
  const segments = fullpath2.split("/");
  const expanded = /* @__PURE__ */ new Set();
  for (let result of recurse(segments, 0)) {
    if (result !== "/") result = result.replace(/\/$/, "");
    expanded.add(result);
  }
  return expanded;
}

// typegen/index.ts
async function clearRouteModuleAnnotations(ctx) {
  await import_promises.default.rm(
    Path4.join(typesDirectory(ctx), Path4.basename(ctx.config.appDirectory)),
    { recursive: true, force: true }
  );
}
async function write(...files) {
  return Promise.all(
    files.map(async ({ filename: filename2, content }) => {
      await import_promises.default.mkdir(Path4.dirname(filename2), { recursive: true });
      await import_promises.default.writeFile(filename2, content);
    })
  );
}
async function watch(rootDirectory, { mode, logger, rsc }) {
  const ctx = await createContext2({ rootDirectory, mode, rsc, watch: true });
  await import_promises.default.rm(typesDirectory(ctx), { recursive: true, force: true });
  await write(
    generateFuture(ctx),
    generateServerBuild(ctx),
    ...generateRoutes(ctx)
  );
  logger?.info((0, import_picocolors2.green)("generated types"), { timestamp: true, clear: true });
  ctx.configLoader.onChange(
    async ({ result, configChanged, routeConfigChanged }) => {
      if (!result.ok) {
        logger?.error((0, import_picocolors2.red)(result.error), { timestamp: true, clear: true });
        return;
      }
      ctx.config = result.value;
      if (configChanged) {
        await write(generateFuture(ctx));
        logger?.info((0, import_picocolors2.green)("regenerated types"), {
          timestamp: true,
          clear: true
        });
      }
      if (routeConfigChanged) {
        await clearRouteModuleAnnotations(ctx);
        await write(...generateRoutes(ctx));
        logger?.info((0, import_picocolors2.green)("regenerated types"), {
          timestamp: true,
          clear: true
        });
      }
    }
  );
  return {
    close: async () => await ctx.configLoader.close()
  };
}

// vite/rsc/plugin.ts
var import_fs = require("fs");
var import_promises2 = require("fs/promises");
var import_pathe6 = __toESM(require("pathe"));

// vite/has-dependency.ts
function hasDependency({
  name,
  rootDirectory
}) {
  try {
    return Boolean(require.resolve(name, { paths: [rootDirectory] }));
  } catch (err2) {
    return false;
  }
}

// vite/optimize-deps-entries.ts
var import_tinyglobby = require("tinyglobby");

// vite/resolve-relative-route-file-path.ts
var import_pathe4 = __toESM(require("pathe"));
function resolveRelativeRouteFilePath(route, reactRouterConfig) {
  let vite2 = getVite();
  let file = route.file;
  let fullPath = import_pathe4.default.resolve(reactRouterConfig.appDirectory, file);
  return vite2.normalizePath(fullPath);
}

// vite/optimize-deps-entries.ts
function getOptimizeDepsEntries({
  entryClientFilePath,
  reactRouterConfig
}) {
  if (!reactRouterConfig.future.unstable_optimizeDeps) {
    return [];
  }
  const vite2 = getVite();
  const viteMajorVersion = parseInt(vite2.version.split(".")[0], 10);
  return [
    vite2.normalizePath(entryClientFilePath),
    ...Object.values(reactRouterConfig.routes).map(
      (route) => resolveRelativeRouteFilePath(route, reactRouterConfig)
    )
  ].map(
    (entry) => (
      // In Vite 7, the `optimizeDeps.entries` option only accepts glob patterns.
      // In prior versions, absolute file paths were treated differently.
      viteMajorVersion >= 7 ? (0, import_tinyglobby.escapePath)(entry) : entry
    )
  );
}

// vite/rsc/virtual-route-config.ts
var import_pathe5 = __toESM(require("pathe"));
function createVirtualRouteConfig({
  appDirectory,
  routeConfig
}) {
  let routeIdByFile = /* @__PURE__ */ new Map();
  let code = "export default [";
  const closeRouteSymbol = Symbol("CLOSE_ROUTE");
  let stack = [
    ...routeConfig
  ];
  while (stack.length > 0) {
    const route = stack.pop();
    if (!route) break;
    if (route === closeRouteSymbol) {
      code += "]},";
      continue;
    }
    code += "{";
    const routeFile = import_pathe5.default.resolve(appDirectory, route.file);
    const routeId = route.id || createRouteId2(route.file, appDirectory);
    routeIdByFile.set(routeFile, routeId);
    code += `lazy: () => import(${JSON.stringify(
      `${routeFile}?route-module`
    )}),`;
    code += `id: ${JSON.stringify(routeId)},`;
    if (typeof route.path === "string") {
      code += `path: ${JSON.stringify(route.path)},`;
    }
    if (route.index) {
      code += `index: true,`;
    }
    if (route.caseSensitive) {
      code += `caseSensitive: true,`;
    }
    if (route.children) {
      code += ["children:["];
      stack.push(closeRouteSymbol);
      stack.push(...[...route.children].reverse());
    } else {
      code += "},";
    }
  }
  code += "];\n";
  return { code, routeIdByFile };
}
function createRouteId2(file, appDirectory) {
  return import_pathe5.default.relative(appDirectory, file).replace(/\\+/, "/").slice(0, -import_pathe5.default.extname(file).length);
}

// vite/rsc/virtual-route-modules.ts
var import_es_module_lexer = require("es-module-lexer");

// vite/remove-exports.ts
var import_babel_dead_code_elimination = require("babel-dead-code-elimination");
var removeExports = (ast, exportsToRemove) => {
  let previouslyReferencedIdentifiers = (0, import_babel_dead_code_elimination.findReferencedIdentifiers)(ast);
  let exportsFiltered = false;
  let markedForRemoval = /* @__PURE__ */ new Set();
  let removedExportLocalNames = /* @__PURE__ */ new Set();
  traverse(ast, {
    ExportDeclaration(path6) {
      if (path6.node.type === "ExportNamedDeclaration") {
        if (path6.node.specifiers.length) {
          path6.node.specifiers = path6.node.specifiers.filter((specifier) => {
            if (specifier.type === "ExportSpecifier" && specifier.exported.type === "Identifier") {
              if (exportsToRemove.includes(specifier.exported.name)) {
                exportsFiltered = true;
                if (specifier.local && specifier.local.name !== specifier.exported.name) {
                  removedExportLocalNames.add(specifier.local.name);
                }
                return false;
              }
            }
            return true;
          });
          if (path6.node.specifiers.length === 0) {
            markedForRemoval.add(path6);
          }
        }
        if (path6.node.declaration?.type === "VariableDeclaration") {
          let declaration = path6.node.declaration;
          declaration.declarations = declaration.declarations.filter(
            (declaration2) => {
              if (declaration2.id.type === "Identifier" && exportsToRemove.includes(declaration2.id.name)) {
                exportsFiltered = true;
                return false;
              }
              if (declaration2.id.type === "ArrayPattern" || declaration2.id.type === "ObjectPattern") {
                validateDestructuredExports(declaration2.id, exportsToRemove);
              }
              return true;
            }
          );
          if (declaration.declarations.length === 0) {
            markedForRemoval.add(path6);
          }
        }
        if (path6.node.declaration?.type === "FunctionDeclaration") {
          let id = path6.node.declaration.id;
          if (id && exportsToRemove.includes(id.name)) {
            markedForRemoval.add(path6);
          }
        }
        if (path6.node.declaration?.type === "ClassDeclaration") {
          let id = path6.node.declaration.id;
          if (id && exportsToRemove.includes(id.name)) {
            markedForRemoval.add(path6);
          }
        }
      }
      if (path6.node.type === "ExportDefaultDeclaration") {
        if (exportsToRemove.includes("default")) {
          markedForRemoval.add(path6);
          if (path6.node.declaration) {
            if (path6.node.declaration.type === "Identifier") {
              removedExportLocalNames.add(path6.node.declaration.name);
            } else if ((path6.node.declaration.type === "FunctionDeclaration" || path6.node.declaration.type === "ClassDeclaration") && path6.node.declaration.id) {
              removedExportLocalNames.add(path6.node.declaration.id.name);
            }
          }
        }
      }
    }
  });
  traverse(ast, {
    ExpressionStatement(path6) {
      if (!path6.parentPath.isProgram()) {
        return;
      }
      if (path6.node.expression.type === "AssignmentExpression") {
        const left = path6.node.expression.left;
        if (left.type === "MemberExpression" && left.object.type === "Identifier" && (exportsToRemove.includes(left.object.name) || removedExportLocalNames.has(left.object.name))) {
          markedForRemoval.add(path6);
        }
      }
    }
  });
  if (markedForRemoval.size > 0 || exportsFiltered) {
    for (let path6 of markedForRemoval) {
      path6.remove();
    }
    (0, import_babel_dead_code_elimination.deadCodeElimination)(ast, previouslyReferencedIdentifiers);
  }
};
function validateDestructuredExports(id, exportsToRemove) {
  if (id.type === "ArrayPattern") {
    for (let element of id.elements) {
      if (!element) {
        continue;
      }
      if (element.type === "Identifier" && exportsToRemove.includes(element.name)) {
        throw invalidDestructureError(element.name);
      }
      if (element.type === "RestElement" && element.argument.type === "Identifier" && exportsToRemove.includes(element.argument.name)) {
        throw invalidDestructureError(element.argument.name);
      }
      if (element.type === "ArrayPattern" || element.type === "ObjectPattern") {
        validateDestructuredExports(element, exportsToRemove);
      }
    }
  }
  if (id.type === "ObjectPattern") {
    for (let property of id.properties) {
      if (!property) {
        continue;
      }
      if (property.type === "ObjectProperty" && property.key.type === "Identifier") {
        if (property.value.type === "Identifier" && exportsToRemove.includes(property.value.name)) {
          throw invalidDestructureError(property.value.name);
        }
        if (property.value.type === "ArrayPattern" || property.value.type === "ObjectPattern") {
          validateDestructuredExports(property.value, exportsToRemove);
        }
      }
      if (property.type === "RestElement" && property.argument.type === "Identifier" && exportsToRemove.includes(property.argument.name)) {
        throw invalidDestructureError(property.argument.name);
      }
    }
  }
}
function invalidDestructureError(name) {
  return new Error(`Cannot remove destructured export "${name}"`);
}

// vite/rsc/virtual-route-modules.ts
var SERVER_ONLY_COMPONENT_EXPORTS = ["ServerComponent"];
var SERVER_ONLY_ROUTE_EXPORTS = [
  ...SERVER_ONLY_COMPONENT_EXPORTS,
  "loader",
  "action",
  "middleware",
  "headers"
];
var SERVER_ONLY_ROUTE_EXPORTS_SET = new Set(SERVER_ONLY_ROUTE_EXPORTS);
function isServerOnlyRouteExport(name) {
  return SERVER_ONLY_ROUTE_EXPORTS_SET.has(name);
}
var COMMON_COMPONENT_EXPORTS = [
  "ErrorBoundary",
  "HydrateFallback",
  "Layout"
];
var SERVER_FIRST_COMPONENT_EXPORTS = [
  ...COMMON_COMPONENT_EXPORTS,
  ...SERVER_ONLY_COMPONENT_EXPORTS
];
var SERVER_FIRST_COMPONENT_EXPORTS_SET = new Set(
  SERVER_FIRST_COMPONENT_EXPORTS
);
function isServerFirstComponentExport(name) {
  return SERVER_FIRST_COMPONENT_EXPORTS_SET.has(
    name
  );
}
var CLIENT_COMPONENT_EXPORTS = [
  ...COMMON_COMPONENT_EXPORTS,
  "default"
];
var CLIENT_NON_COMPONENT_EXPORTS = [
  "clientAction",
  "clientLoader",
  "clientMiddleware",
  "handle",
  "meta",
  "links",
  "shouldRevalidate"
];
var CLIENT_NON_COMPONENT_EXPORTS_SET = new Set(CLIENT_NON_COMPONENT_EXPORTS);
function isClientNonComponentExport(name) {
  return CLIENT_NON_COMPONENT_EXPORTS_SET.has(name);
}
var CLIENT_ROUTE_EXPORTS = [
  ...CLIENT_NON_COMPONENT_EXPORTS,
  ...CLIENT_COMPONENT_EXPORTS
];
var CLIENT_ROUTE_EXPORTS_SET = new Set(CLIENT_ROUTE_EXPORTS);
function isClientRouteExport(name) {
  return CLIENT_ROUTE_EXPORTS_SET.has(name);
}
var ROUTE_EXPORTS = [
  ...SERVER_ONLY_ROUTE_EXPORTS,
  ...CLIENT_ROUTE_EXPORTS
];
var ROUTE_EXPORTS_SET = new Set(ROUTE_EXPORTS);
function isRouteExport(name) {
  return ROUTE_EXPORTS_SET.has(name);
}
function isCustomRouteExport(name) {
  return !isRouteExport(name);
}
function hasReactServerCondition(viteEnvironment) {
  return viteEnvironment.config.resolve.conditions.includes("react-server");
}
function transformVirtualRouteModules({
  id,
  code,
  viteCommand,
  routeIdByFile,
  rootRouteFile,
  viteEnvironment
}) {
  if (isVirtualRouteModuleId(id) || routeIdByFile.has(id)) {
    return createVirtualRouteModuleCode({
      id,
      code,
      rootRouteFile,
      viteCommand,
      viteEnvironment
    });
  }
  if (isVirtualServerRouteModuleId(id)) {
    return createVirtualServerRouteModuleCode({
      id,
      code,
      viteEnvironment
    });
  }
  if (isVirtualClientRouteModuleId(id)) {
    return createVirtualClientRouteModuleCode({
      id,
      code,
      rootRouteFile,
      viteCommand
    });
  }
}
async function createVirtualRouteModuleCode({
  id,
  code: routeSource,
  rootRouteFile,
  viteCommand,
  viteEnvironment
}) {
  const isReactServer = hasReactServerCondition(viteEnvironment);
  const { staticExports, isServerFirstRoute, hasClientExports } = parseRouteExports(routeSource);
  const clientModuleId = getVirtualClientModuleId(id);
  const serverModuleId = getVirtualServerModuleId(id);
  let code = "";
  if (isServerFirstRoute) {
    if (staticExports.some(isServerFirstComponentExport)) {
      code += `import React from "react";
`;
    }
    for (const staticExport of staticExports) {
      if (isClientNonComponentExport(staticExport)) {
        code += `export { ${staticExport} } from "${clientModuleId}";
`;
      } else if (isReactServer && isServerFirstComponentExport(staticExport) && // Layout wraps all other component exports so doesn't need CSS injected
      staticExport !== "Layout") {
        code += `import { ${staticExport} as ${staticExport}WithoutCss } from "${serverModuleId}";
`;
        code += `export ${staticExport === "ServerComponent" ? "default " : " "}function ${staticExport}(props) {
`;
        code += `  return React.createElement(React.Fragment, null,
`;
        code += `    import.meta.viteRsc.loadCss(),
`;
        code += `    React.createElement(${staticExport}WithoutCss, props),
`;
        code += `  );
`;
        code += `}
`;
      } else if (isReactServer && isRouteExport(staticExport)) {
        code += `export { ${staticExport} } from "${serverModuleId}";
`;
      } else if (isCustomRouteExport(staticExport)) {
        code += `export { ${staticExport} } from "${isReactServer ? serverModuleId : clientModuleId}";
`;
      }
    }
    if (viteCommand === "serve" && !hasClientExports) {
      code += `export { __ensureClientRouteModuleForHMR } from "${clientModuleId}";
`;
    }
  } else {
    for (const staticExport of staticExports) {
      if (isClientRouteExport(staticExport)) {
        code += `export { ${staticExport} } from "${clientModuleId}";
`;
      } else if (isReactServer && isServerOnlyRouteExport(staticExport)) {
        code += `export { ${staticExport} } from "${serverModuleId}";
`;
      } else if (isCustomRouteExport(staticExport)) {
        code += `export { ${staticExport} } from "${isReactServer ? serverModuleId : clientModuleId}";
`;
      }
    }
  }
  if (isRootRouteFile({ id, rootRouteFile }) && !staticExports.includes("ErrorBoundary")) {
    code += `export { ErrorBoundary } from "${clientModuleId}";
`;
  }
  return code;
}
function createVirtualServerRouteModuleCode({
  id,
  code: routeSource,
  viteEnvironment
}) {
  if (!hasReactServerCondition(viteEnvironment)) {
    throw new Error(
      [
        "Virtual server route module was loaded outside of the RSC environment.",
        `Environment Name: ${viteEnvironment.name}`,
        `Module ID: ${id}`
      ].join("\n")
    );
  }
  const { staticExports, isServerFirstRoute } = parseRouteExports(routeSource);
  const clientModuleId = getVirtualClientModuleId(id);
  const serverRouteModuleAst = import_parser.parse(routeSource, {
    sourceType: "module"
  });
  removeExports(
    serverRouteModuleAst,
    isServerFirstRoute ? CLIENT_NON_COMPONENT_EXPORTS : CLIENT_ROUTE_EXPORTS
  );
  const generatorResult = generate(serverRouteModuleAst);
  if (!isServerFirstRoute) {
    for (const staticExport of staticExports) {
      if (isClientRouteExport(staticExport)) {
        generatorResult.code += "\n";
        generatorResult.code += `export { ${staticExport} } from "${clientModuleId}";
`;
      }
    }
  }
  return generatorResult;
}
function createVirtualClientRouteModuleCode({
  id,
  code: routeSource,
  rootRouteFile,
  viteCommand
}) {
  const { staticExports, isServerFirstRoute, hasClientExports } = parseRouteExports(routeSource);
  const exportsToRemove = isServerFirstRoute ? [...SERVER_ONLY_ROUTE_EXPORTS, ...CLIENT_COMPONENT_EXPORTS] : SERVER_ONLY_ROUTE_EXPORTS;
  const clientRouteModuleAst = import_parser.parse(routeSource, {
    sourceType: "module"
  });
  removeExports(clientRouteModuleAst, exportsToRemove);
  const generatorResult = generate(clientRouteModuleAst);
  generatorResult.code = '"use client";' + generatorResult.code;
  if (isRootRouteFile({ id, rootRouteFile }) && !staticExports.includes("ErrorBoundary")) {
    const hasRootLayout = staticExports.includes("Layout");
    generatorResult.code += `
import { createElement as __rr_createElement } from "react";
`;
    generatorResult.code += `import { UNSAFE_RSCDefaultRootErrorBoundary } from "react-router";
`;
    generatorResult.code += `export function ErrorBoundary() {
`;
    generatorResult.code += `  return __rr_createElement(UNSAFE_RSCDefaultRootErrorBoundary, { hasRootLayout: ${hasRootLayout} });
`;
    generatorResult.code += `}
`;
  }
  if (viteCommand === "serve" && isServerFirstRoute && !hasClientExports) {
    generatorResult.code += `
export const __ensureClientRouteModuleForHMR = true;`;
  }
  return generatorResult;
}
function parseRouteExports(code) {
  const [, exportSpecifiers] = (0, import_es_module_lexer.parse)(code);
  const staticExports = exportSpecifiers.map(({ n: name }) => name);
  const isServerFirstRoute = staticExports.some(
    (staticExport) => staticExport === "ServerComponent"
  );
  return {
    staticExports,
    isServerFirstRoute,
    hasClientExports: staticExports.some(
      isServerFirstRoute ? isClientNonComponentExport : isClientRouteExport
    )
  };
}
function getVirtualClientModuleId(id) {
  return `${id.split("?")[0]}?client-route-module`;
}
function getVirtualServerModuleId(id) {
  return `${id.split("?")[0]}?server-route-module`;
}
function isVirtualRouteModuleId(id) {
  return /(\?|&)route-module(&|$)/.test(id);
}
function isVirtualClientRouteModuleId(id) {
  return /(\?|&)client-route-module(&|$)/.test(id);
}
function isVirtualServerRouteModuleId(id) {
  return /(\?|&)server-route-module(&|$)/.test(id);
}
function isRootRouteFile({
  id,
  rootRouteFile
}) {
  const filePath = id.split("?")[0];
  return filePath === rootRouteFile;
}

// vite/load-dotenv.ts
async function loadDotenv({
  rootDirectory,
  viteUserConfig,
  mode
}) {
  const vite2 = await import("vite");
  Object.assign(
    process.env,
    vite2.loadEnv(
      mode,
      viteUserConfig.envDir ?? rootDirectory,
      // We override the default prefix of "VITE_" with a blank string since
      // we're targeting the server, so we want to load all environment
      // variables, not just those explicitly marked for the client
      ""
    )
  );
}

// vite/plugins/validate-plugin-order.ts
function validatePluginOrder() {
  return {
    name: "react-router:validate-plugin-order",
    configResolved(viteConfig) {
      let pluginIndex = (pluginName) => {
        pluginName = Array.isArray(pluginName) ? pluginName : [pluginName];
        return viteConfig.plugins.findIndex(
          (plugin) => pluginName.includes(plugin.name)
        );
      };
      let reactRouterRscPluginIndex = pluginIndex("react-router/rsc");
      let viteRscPluginIndex = pluginIndex("rsc");
      if (reactRouterRscPluginIndex >= 0 && viteRscPluginIndex >= 0 && reactRouterRscPluginIndex > viteRscPluginIndex) {
        throw new Error(
          `The "@vitejs/plugin-rsc" plugin should be placed after the React Router RSC plugin in your Vite config`
        );
      }
      let reactRouterPluginIndex = pluginIndex([
        "react-router",
        "react-router/rsc"
      ]);
      let mdxPluginIndex = pluginIndex("@mdx-js/rollup");
      if (mdxPluginIndex >= 0 && mdxPluginIndex > reactRouterPluginIndex) {
        throw new Error(
          `The "@mdx-js/rollup" plugin should be placed before the React Router plugin in your Vite config`
        );
      }
    }
  };
}

// vite/plugins/warn-on-client-source-maps.ts
var import_picocolors3 = __toESM(require("picocolors"));
function warnOnClientSourceMaps() {
  let viteConfig;
  let viteCommand;
  let logged = false;
  return {
    name: "react-router:warn-on-client-source-maps",
    config(_, configEnv) {
      viteCommand = configEnv.command;
    },
    configResolved(config) {
      viteConfig = config;
    },
    buildStart() {
      invariant(viteConfig);
      if (!logged && viteCommand === "build" && viteConfig.mode === "production" && !viteConfig.build.ssr && (viteConfig.build.sourcemap || viteConfig.environments?.client?.build.sourcemap)) {
        viteConfig.logger.warn(
          import_picocolors3.default.yellow(
            "\n" + import_picocolors3.default.bold("  \u26A0\uFE0F  Source maps are enabled in production\n") + [
              "This makes your server code publicly",
              "visible in the browser. This is highly",
              "discouraged! If you insist, ensure that",
              "you are using environment variables for",
              "secrets and not hard-coding them in",
              "your source code."
            ].map((line) => "     " + line).join("\n") + "\n"
          )
        );
        logged = true;
      }
    }
  };
}

// vite/rsc/plugin.ts
function reactRouterRSCVitePlugin() {
  let configLoader;
  let typegenWatcherPromise;
  let viteCommand;
  let routeIdByFile;
  let logger;
  const defaultEntries = getDefaultEntries();
  let config;
  let rootRouteFile;
  function updateConfig(newConfig) {
    config = newConfig;
    rootRouteFile = Path5.resolve(
      newConfig.appDirectory,
      newConfig.routes.root.file
    );
  }
  return [
    {
      name: "react-router/rsc",
      async config(viteUserConfig, { command, mode }) {
        await import_es_module_lexer2.init;
        await preloadVite();
        viteCommand = command;
        const rootDirectory = getRootDirectory(viteUserConfig);
        const watch2 = command === "serve";
        configLoader = await createConfigLoader({
          rootDirectory,
          mode,
          watch: watch2,
          validateConfig: (userConfig) => {
            let errors = [];
            if (userConfig.buildEnd) errors.push("buildEnd");
            if (userConfig.prerender) errors.push("prerender");
            if (userConfig.presets?.length) errors.push("presets");
            if (userConfig.routeDiscovery) errors.push("routeDiscovery");
            if (userConfig.serverBundles) errors.push("serverBundles");
            if (userConfig.ssr === false) errors.push("ssr: false");
            if (userConfig.future?.unstable_splitRouteModules)
              errors.push("future.unstable_splitRouteModules");
            if (userConfig.future?.unstable_viteEnvironmentApi === false)
              errors.push("future.unstable_viteEnvironmentApi: false");
            if (userConfig.future?.v8_middleware === false)
              errors.push("future.v8_middleware: false");
            if (userConfig.future?.unstable_subResourceIntegrity)
              errors.push("future.unstable_subResourceIntegrity");
            if (errors.length) {
              return `RSC Framework Mode does not currently support the following React Router config:
${errors.map((x) => ` - ${x}`).join("\n")}
`;
            }
          }
        });
        const configResult = await configLoader.getConfig();
        if (!configResult.ok) throw new Error(configResult.error);
        updateConfig(configResult.value);
        if (viteUserConfig.base && config.basename !== "/" && viteCommand === "serve" && !viteUserConfig.server?.middlewareMode && !config.basename.startsWith(viteUserConfig.base)) {
          throw new Error(
            "When using the React Router `basename` and the Vite `base` config, the `basename` config must begin with `base` for the default Vite dev server."
          );
        }
        await loadDotenv({
          rootDirectory,
          viteUserConfig,
          mode
        });
        const vite2 = await import("vite");
        logger = vite2.createLogger(viteUserConfig.logLevel, {
          prefix: "[react-router]"
        });
        return {
          resolve: {
            dedupe: [
              // https://react.dev/warnings/invalid-hook-call-warning#duplicate-react
              "react",
              "react-dom",
              // Avoid router duplicates since mismatching routers cause `Error:
              // You must render this element inside a <Remix> element`.
              "react-router",
              "react-router/dom",
              ...hasDependency({ name: "react-router-dom", rootDirectory }) ? ["react-router-dom"] : []
            ]
          },
          optimizeDeps: {
            entries: getOptimizeDepsEntries({
              entryClientFilePath: defaultEntries.client,
              reactRouterConfig: config
            }),
            esbuildOptions: {
              jsx: "automatic"
            },
            include: [
              // Pre-bundle React dependencies to avoid React duplicates,
              // even if React dependencies are not direct dependencies.
              // https://react.dev/warnings/invalid-hook-call-warning#duplicate-react
              "react",
              "react/jsx-runtime",
              "react/jsx-dev-runtime",
              "react-dom",
              "react-dom/client",
              "react-router/internal/react-server-client"
            ]
          },
          esbuild: {
            jsx: "automatic",
            jsxDev: viteCommand !== "build"
          },
          environments: {
            client: {
              build: {
                rollupOptions: {
                  input: {
                    index: defaultEntries.client
                  }
                },
                outDir: (0, import_pathe6.join)(config.buildDirectory, "client")
              }
            },
            rsc: {
              build: {
                rollupOptions: {
                  input: {
                    // We use a virtual entry here so that consumers can import
                    // it as `virtual:react-router/unstable_rsc/rsc-entry`
                    // without needing to know the actual file path, which is
                    // important when using the default entries.
                    index: defaultEntries.rsc
                  },
                  output: {
                    entryFileNames: config.serverBuildFile,
                    format: config.serverModuleFormat
                  }
                },
                outDir: (0, import_pathe6.join)(config.buildDirectory, "server")
              }
            },
            ssr: {
              build: {
                rollupOptions: {
                  input: {
                    index: defaultEntries.ssr
                  },
                  output: {
                    // Note: We don't set `entryFileNames` here because it's
                    // considered private to the RSC environment build, and
                    // @vitejs/plugin-rsc currently breaks if it's set to
                    // something other than `index.js`.
                    format: config.serverModuleFormat
                  }
                },
                outDir: (0, import_pathe6.join)(config.buildDirectory, "server/__ssr_build")
              }
            }
          },
          build: {
            rollupOptions: {
              // Copied from https://github.com/vitejs/vite-plugin-react/blob/c602225271d4acf462ba00f8d6d8a2e42492c5cd/packages/common/warning.ts
              onwarn(warning, defaultHandler) {
                if (warning.code === "MODULE_LEVEL_DIRECTIVE" && (warning.message.includes("use client") || warning.message.includes("use server"))) {
                  return;
                }
                if (warning.code === "SOURCEMAP_ERROR" && warning.message.includes("resolve original location") && warning.pos === 0) {
                  return;
                }
                if (viteUserConfig.build?.rollupOptions?.onwarn) {
                  viteUserConfig.build.rollupOptions.onwarn(
                    warning,
                    defaultHandler
                  );
                } else {
                  defaultHandler(warning);
                }
              }
            }
          }
        };
      },
      async configureServer(viteDevServer) {
        configLoader.onChange(
          async ({
            result,
            configCodeChanged,
            routeConfigCodeChanged,
            configChanged,
            routeConfigChanged
          }) => {
            if (!result.ok) {
              invalidateVirtualModules(viteDevServer);
              logger.error(result.error, {
                clear: true,
                timestamp: true
              });
              return;
            }
            let message = configChanged ? "Config changed." : routeConfigChanged ? "Route config changed." : configCodeChanged ? "Config saved." : routeConfigCodeChanged ? " Route config saved." : "Config saved";
            logger.info(import_picocolors4.default.green(message), {
              clear: true,
              timestamp: true
            });
            updateConfig(result.value);
            if (configChanged || routeConfigChanged) {
              invalidateVirtualModules(viteDevServer);
            }
          }
        );
      },
      async buildEnd() {
        await configLoader.close();
      }
    },
    {
      name: "react-router/rsc/typegen",
      async config(viteUserConfig, { command, mode }) {
        if (command === "serve") {
          const vite2 = await import("vite");
          typegenWatcherPromise = watch(
            getRootDirectory(viteUserConfig),
            {
              mode,
              rsc: true,
              // ignore `info` logs from typegen since they are
              // redundant when Vite plugin logs are active
              logger: vite2.createLogger("warn", {
                prefix: "[react-router]"
              })
            }
          );
        }
      },
      async buildEnd() {
        (await typegenWatcherPromise)?.close();
      }
    },
    {
      name: "react-router/rsc/virtual-rsc-entry",
      resolveId(id) {
        if (id === virtual.rscEntry.id) return defaultEntries.rsc;
      }
    },
    {
      name: "react-router/rsc/virtual-route-config",
      resolveId(id) {
        if (id === virtual.routeConfig.id) {
          return virtual.routeConfig.resolvedId;
        }
      },
      load(id) {
        if (id === virtual.routeConfig.resolvedId) {
          const result = createVirtualRouteConfig({
            appDirectory: config.appDirectory,
            routeConfig: config.unstable_routeConfig
          });
          routeIdByFile = result.routeIdByFile;
          return result.code;
        }
      }
    },
    {
      name: "react-router/rsc/virtual-route-modules",
      transform(code, id) {
        if (!routeIdByFile) return;
        return transformVirtualRouteModules({
          code,
          id,
          viteCommand,
          routeIdByFile,
          rootRouteFile,
          viteEnvironment: this.environment
        });
      }
    },
    {
      name: "react-router/rsc/virtual-basename",
      resolveId(id) {
        if (id === virtual.basename.id) {
          return virtual.basename.resolvedId;
        }
      },
      load(id) {
        if (id === virtual.basename.resolvedId) {
          return `export default ${JSON.stringify(config.basename)};`;
        }
      }
    },
    {
      name: "react-router/rsc/hmr/inject-runtime",
      enforce: "pre",
      resolveId(id) {
        if (id === virtual.injectHmrRuntime.id) {
          return virtual.injectHmrRuntime.resolvedId;
        }
      },
      async load(id) {
        if (id !== virtual.injectHmrRuntime.resolvedId) return;
        return viteCommand === "serve" ? [
          `import RefreshRuntime from "${virtual.hmrRuntime.id}"`,
          "RefreshRuntime.injectIntoGlobalHook(window)",
          "window.$RefreshReg$ = () => {}",
          "window.$RefreshSig$ = () => (type) => type",
          "window.__vite_plugin_react_preamble_installed__ = true"
        ].join("\n") : "";
      }
    },
    {
      name: "react-router/rsc/hmr/runtime",
      enforce: "pre",
      resolveId(id) {
        if (id === virtual.hmrRuntime.id) return virtual.hmrRuntime.resolvedId;
      },
      async load(id) {
        if (id !== virtual.hmrRuntime.resolvedId) return;
        const reactRefreshDir = import_pathe6.default.dirname(
          require.resolve("react-refresh/package.json")
        );
        const reactRefreshRuntimePath = import_pathe6.default.join(
          reactRefreshDir,
          "cjs/react-refresh-runtime.development.js"
        );
        return [
          "const exports = {}",
          await (0, import_promises2.readFile)(reactRefreshRuntimePath, "utf8"),
          await (0, import_promises2.readFile)(
            require.resolve("./static/rsc-refresh-utils.mjs"),
            "utf8"
          ),
          "export default exports"
        ].join("\n");
      }
    },
    {
      name: "react-router/rsc/hmr/react-refresh",
      async transform(code, id, options) {
        if (viteCommand !== "serve") return;
        if (id.includes("/node_modules/")) return;
        const filepath = id.split("?")[0];
        const extensionsRE = /\.(jsx?|tsx?|mdx?)$/;
        if (!extensionsRE.test(filepath)) return;
        const devRuntime = "react/jsx-dev-runtime";
        const ssr = options?.ssr === true;
        const isJSX = filepath.endsWith("x");
        const useFastRefresh = !ssr && (isJSX || code.includes(devRuntime));
        if (!useFastRefresh) return;
        if (isVirtualClientRouteModuleId(id)) {
          const routeId = routeIdByFile?.get(filepath);
          return { code: addRefreshWrapper({ routeId, code, id }) };
        }
        const result = await babel.transformAsync(code, {
          babelrc: false,
          configFile: false,
          filename: id,
          sourceFileName: filepath,
          parserOpts: {
            sourceType: "module",
            allowAwaitOutsideFunction: true
          },
          plugins: [[require("react-refresh/babel"), { skipEnvCheck: true }]],
          sourceMaps: true
        });
        if (result === null) return;
        code = result.code;
        const refreshContentRE = /\$Refresh(?:Reg|Sig)\$\(/;
        if (refreshContentRE.test(code)) {
          code = addRefreshWrapper({ code, id });
        }
        return { code, map: result.map };
      }
    },
    {
      name: "react-router/rsc/hmr/updates",
      async hotUpdate({ server, file, modules }) {
        if (this.environment.name !== "rsc") return;
        const clientModules = server.environments.client.moduleGraph.getModulesByFile(file);
        const vite2 = await import("vite");
        const isServerOnlyChange = !clientModules || clientModules.size === 0 || // Handle CSS injected from server-first routes (with ?direct query
        // string) since the client graph has a reference to the CSS
        vite2.isCSSRequest(file) && Array.from(clientModules).some(
          (mod) => mod.id?.includes("?direct")
        );
        for (const mod of getModulesWithImporters(modules)) {
          if (!mod.file) continue;
          const normalizedPath = import_pathe6.default.normalize(mod.file);
          const routeId = routeIdByFile?.get(normalizedPath);
          if (routeId !== void 0) {
            const routeSource = await (0, import_promises2.readFile)(normalizedPath, "utf8");
            const virtualRouteModuleCode = (await server.environments.rsc.pluginContainer.transform(
              routeSource,
              `${normalizedPath}?route-module`
            )).code;
            const { staticExports } = parseRouteExports(virtualRouteModuleCode);
            const hasAction = staticExports.includes("action");
            const hasComponent = staticExports.includes("default");
            const hasErrorBoundary = staticExports.includes("ErrorBoundary");
            const hasLoader = staticExports.includes("loader");
            server.hot.send({
              type: "custom",
              event: "react-router:hmr",
              data: {
                routeId,
                isServerOnlyChange,
                hasAction,
                hasComponent,
                hasErrorBoundary,
                hasLoader
              }
            });
          }
        }
        return modules;
      }
    },
    validatePluginOrder(),
    warnOnClientSourceMaps()
  ];
}
var virtual = {
  routeConfig: create("unstable_rsc/routes"),
  injectHmrRuntime: create("unstable_rsc/inject-hmr-runtime"),
  hmrRuntime: create("unstable_rsc/runtime"),
  basename: create("unstable_rsc/basename"),
  rscEntry: create("unstable_rsc/rsc-entry")
};
function invalidateVirtualModules(viteDevServer) {
  for (const vmod of Object.values(virtual)) {
    for (const env of Object.values(viteDevServer.environments)) {
      const mod = env.moduleGraph.getModuleById(vmod.resolvedId);
      if (mod) {
        env.moduleGraph.invalidateModule(mod);
      }
    }
  }
}
function getRootDirectory(viteUserConfig) {
  return viteUserConfig.root ?? process.env.REACT_ROUTER_ROOT ?? process.cwd();
}
function getDevPackageRoot() {
  const currentDir = (0, import_pathe6.dirname)(__dirname);
  let dir = currentDir;
  while (dir !== (0, import_pathe6.dirname)(dir)) {
    try {
      const packageJsonPath = (0, import_pathe6.join)(dir, "package.json");
      (0, import_fs.readFileSync)(packageJsonPath, "utf-8");
      return dir;
    } catch {
      dir = (0, import_pathe6.dirname)(dir);
    }
  }
  throw new Error("Could not find package.json");
}
function getDefaultEntries() {
  const defaultEntriesDir = (0, import_pathe6.join)(
    getDevPackageRoot(),
    "dist",
    "config",
    "default-rsc-entries"
  );
  return {
    rsc: (0, import_pathe6.join)(defaultEntriesDir, "entry.rsc.tsx"),
    ssr: (0, import_pathe6.join)(defaultEntriesDir, "entry.ssr.tsx"),
    client: (0, import_pathe6.join)(defaultEntriesDir, "entry.client.tsx")
  };
}
function getModulesWithImporters(modules) {
  const visited = /* @__PURE__ */ new Set();
  const result = /* @__PURE__ */ new Set();
  function walk(module2) {
    if (visited.has(module2)) return;
    visited.add(module2);
    result.add(module2);
    for (const importer of module2.importers) {
      walk(importer);
    }
  }
  for (const module2 of modules) {
    walk(module2);
  }
  return result;
}
function addRefreshWrapper({
  routeId,
  code,
  id
}) {
  const acceptExports = routeId !== void 0 ? CLIENT_NON_COMPONENT_EXPORTS : [];
  return REACT_REFRESH_HEADER.replaceAll("__SOURCE__", JSON.stringify(id)) + code + REACT_REFRESH_FOOTER.replaceAll("__SOURCE__", JSON.stringify(id)).replaceAll("__ACCEPT_EXPORTS__", JSON.stringify(acceptExports)).replaceAll("__ROUTE_ID__", JSON.stringify(routeId));
}
var REACT_REFRESH_HEADER = `
import RefreshRuntime from "${virtual.hmrRuntime.id}";

const inWebWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
let prevRefreshReg;
let prevRefreshSig;

if (import.meta.hot && !inWebWorker) {
  if (!window.__vite_plugin_react_preamble_installed__) {
    throw new Error(
      "React Router Vite plugin can't detect preamble. Something is wrong."
    );
  }

  prevRefreshReg = window.$RefreshReg$;
  prevRefreshSig = window.$RefreshSig$;
  window.$RefreshReg$ = (type, id) => {
    RefreshRuntime.register(type, __SOURCE__ + " " + id)
  };
  window.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;
}`.replaceAll("\n", "");
var REACT_REFRESH_FOOTER = `
if (import.meta.hot && !inWebWorker) {
  window.$RefreshReg$ = prevRefreshReg;
  window.$RefreshSig$ = prevRefreshSig;
  RefreshRuntime.__hmr_import(import.meta.url).then((currentExports) => {
    RefreshRuntime.registerExportsForReactRefresh(__SOURCE__, currentExports);
    import.meta.hot.accept((nextExports) => {
      if (!nextExports) return;
      __ROUTE_ID__ && window.__reactRouterRouteModuleUpdates.set(__ROUTE_ID__, nextExports);
      const invalidateMessage = RefreshRuntime.validateRefreshBoundaryAndEnqueueUpdate(currentExports, nextExports, __ACCEPT_EXPORTS__);
      if (invalidateMessage) import.meta.hot.invalidate(invalidateMessage);
    });
  });
}`;

// internal.ts
var __INTERNAL_DO_NOT_USE_OR_YOU_WILL_GET_A_STRONGLY_WORDED_LETTER__ = {
  unstable_reactRouterRSC: reactRouterRSCVitePlugin
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  __INTERNAL_DO_NOT_USE_OR_YOU_WILL_GET_A_STRONGLY_WORDED_LETTER__
});
